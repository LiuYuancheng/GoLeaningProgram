package main
//-----------------------------------------------------------------------
// Name:        BoatVarCSVCreator.go
// Purpose:     Convert CommTags.py, BoatVars.py and A9VarsCommon.py to a
//				a csv file with 7 column.("system", "main tag", "Key name",
// 				"Key", "Default Value" , "msg Format/sample", "description")
//
// Author:		Liu Yuancheng
// Created:     2018.12.15
//------------------------------------------------------------------------
import (
	"bufio"
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"strings"
	"time"
)
// Log the file create time at the end of the CSV file.
var dataEnd = [][]string{{"End of all the parameter", " This file is generated by <BoatVarCSVCreator.go>", "Last edit at"+time.Now().String()}}
// add the chinese char column for each name.
var chineseMap map[string]string

// Structure to save the variable data.
type ParamV struct {
	sysName string		// System Name (system var belongs to)
	mainTag string		// Main Tag/key
	KeyName string		// The name of the Key shown in Captain parameter Grid.
	KeyCHStr string		// Chinese string for different KeyName
	KeyStr	string		// The subKey. if mainTag == KeyStr we only use one.
	ValueStr string		// Default value of the parameter.string(parameter)
	msgFmt	string		// Message sample used for communication.
	desp	string		// The detail description of the var.
	permit	string 		// permit of whether can change the parameter by user.
}

func between(value string, a string, b string) string {
	// Get substring between two strings.[under editing: this
	// function currently got a small bug.]
	posFirst := strings.Index(value, a)
	if posFirst == -1 {
		return ""
	}
	posLast := strings.Index(value, b)
	if posLast == -1 {
		return ""
	}
	posFirstAdjusted := posFirst + len(a)
	if posFirstAdjusted >= posLast {
		return ""
	}
	return value[posFirstAdjusted:posLast]
}

func after(value string, a string) string {
	// Get substring after a string.
	pos := strings.LastIndex(value, a)
	if pos == -1 {
		return ""
	}
	adjustedPos := pos + len(a)
	if adjustedPos >= len(value) {
		return ""
	}
	return value[adjustedPos:len(value)]
}

func loadPofile(){
	chineseMap = make(map[string]string) // must make the map again before create a map pair.
	poFileName := "zh_Hans.po"
	fmt.Println("Load Chinese file: " + poFileName)
	file, err := os.Open(poFileName)
	if err != nil{
		fmt.Println(err)
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	key := ""
	value := "无"
	newPair := false
	count := 0
	for scanner.Scan() {
		newline := scanner.Text()
		//count += 1
		if strings.Contains(newline, "msgid"){

			c := strings.Split(newline, "\"")
			key = strings.TrimSpace(c[1])
			if key == "" {continue}
			newPair = true
			//fmt.Println(key)
			}
		if strings.Contains(newline, "msgstr") && newPair{
			c := strings.Split(newline, "\"")
			value = strings.TrimSpace(c[1])
			if key == ""{continue}
			if value == ""{continue}
			newPair = false
			//fmt.Println(value)
			chineseMap[key] = value
			count +=1
		}
	}
	fmt.Println(count)
	fmt.Println(chineseMap)
}

//------------------------------------------------------------------------------
// Main function to convert the file.
//------------------------------------------------------------------------------
func main() {
	// Load the Chinese potable object file for translate matching.
	loadPofile()
	//return
	// Set the file need to read and convert.
	var files = [] string {"CommTags.py", "BoatVars.py", "A9VarsCommon.py"}
	// Set the csv column labels.
	var csvline = [] string{"system", "main tag", "Key name", "变量名称","Key", "Default Value" , "permit", "msg Format/sample", "description"}
	// Create the result storage SCV file and the writer to fill in the data.
	file, err := os.Create("variableList.csv")
	checkError("Cannot create file", err)
	defer file.Close()
	writer := csv.NewWriter(file)
	defer writer.Flush()
	checkError("Cannot write to file", err)

	// read the "*.py" files one by one.
	for _, fileName:= range files{
		fmt.Println("Processing file: " + fileName)
		file, err := os.Open(fileName)
		if err != nil{
			fmt.Println(err)
		}
		defer file.Close()
		// Create a scanner to scan the readIn bytes into lines.
		scanner := bufio.NewScanner(file)
		// use different function to process three kind of py file.
		if fileName == "CommTags.py"{
			parmVal:= new(ParamV) // create the paramValue struct.
			for scanner.Scan() {
				newline := scanner.Text()
				if newline == "\n" || newline == "" {
					continue	// jump over the empty lines.
				}
				if newline[0] != '#' && newline[0] != '"'{
					// Process the code line "COMM_TAG_POS = 'P'#... "
					if  strings.Contains(newline, "COMM"){
						// Log the old parameter(stored) data in the csv file.
						err = writer.Write(csvline)
						checkError("Cannot write to file", err)
						// create a new struct to save the data.
						parmVal = new(ParamV)
						value := strings.Split(newline, "#")
						if len(value) < 2{continue} // comments contents missing.
						content := strings.TrimSpace(value[0])
						cmts := strings.TrimSpace(value[1])
						// Get the data from the code content.
						s :=  strings.Split(content, "=")
						parmVal.KeyName, parmVal.KeyStr = strings.TrimSpace(s[0]), strings.TrimSpace(s[1])
						parmVal.mainTag = parmVal.KeyStr
						parmVal.sysName = strings.Trim(parmVal.KeyName, "COMM_")
						// get the data from the code comments.
						s0 := strings.Trim(parmVal.KeyStr, "'")+";"
						if strings.Contains(cmts, "subtag") {
							// process the comm tag which has sub tag.
							c := strings.Split(cmts, ": ")
							parmVal.desp = strings.TrimSpace(c[0])
							if len(c) > 1 {
								parmVal.mainTag = "'" + string(strings.TrimSpace(c[1])[0]) + "'"
								parmVal.msgFmt = strings.TrimSpace(c[1])
							}
						} else{
							c := strings.Split(cmts, s0)
							parmVal.desp = strings.TrimSpace(c[0])
							if len(c) > 1 {
								parmVal.msgFmt = s0 + strings.TrimSpace(c[1])
							}
						}
						// Set the var edit permit.
						parmVal.permit = "editable"
						parmVal.KeyCHStr = "无"
						// Create the line which will be written in the csv file.
						csvline = [] string{parmVal.sysName, parmVal.mainTag, parmVal.KeyName, parmVal.KeyCHStr, parmVal.KeyStr, parmVal.ValueStr, parmVal.permit, parmVal.msgFmt, parmVal.desp}
						}
					}
				}
			}else{
				// Process the boatVar and A9 var file.
				parmVal:= new(ParamV)	// create the paramValue array.
				content := ""			// Code content.
				comments := ""			// Code comments += the sting in help("<string>")
				newGvVal := false		// Tag to identify start to process a new boatVar.
				systemStr := strings.Trim(fileName, ".py")
				dataStr := ""			// string to store the return value of  <between> and <after>
				for scanner.Scan() {
					newline := scanner.Text()
					if newline != "" && newline[0] == '#' {
						// Deal with the description more than one lines and jump over the comment "#----..."
						if ! strings.Contains(newline, "#----"){
							comments += strings.TrimSpace(strings.Trim(newline, "#"))}
					}else if newline == ""{
						// process the combined code contents.
						if content != ""{
							//fmt.Println(content)
							// Get the A9/boatVar's system name
							nameCategory := between(content, "'), _('","'), '" )
							if nameCategory == ""{
								// special case:   SIMULATOR VARS THAT ARE SENT TO A9
								nameCategory = between(content, "', _('","'), '" )
							}
							parmVal.sysName = systemStr+"[" +nameCategory+"]"

							// Get the A9/boatVar's main tag.
							parmVal.mainTag = "v"

							// Get the A9/boatVar's variable name .
							parmVal.KeyName = between(content, "VAR(_('","'), _('" )
							if parmVal.KeyName == ""{
								// special case:   SIMULATOR VARS THAT ARE SENT TO A9
								parmVal.KeyName = between(content, "= VAR('","', _('" )
							}

							// Get the A9/boatVar's sub tab.
							parmVal.KeyStr = between(content, "'), '","'," )
							if parmVal.KeyStr == ""{
								// special case:   SIMULATOR VARS THAT ARE SENT TO A9
								m := after(content,"'), '" )
								parmVal.KeyStr = strings.Split(m, "'")[0]
							}
							if parmVal.KeyStr == ""{
								// special case:   SIMULATOR VARS THAT ARE SENT TO A9
								parmVal.KeyStr = between(content, "'), '","'," )
							}
							s := strings.Split(content, ",")

							// Get the A9/boatVar's default value:
							parmVal.ValueStr = after(content, parmVal.KeyStr+"', ")
							// if the value is a list. such as  [a , b, c]
							if strings.Contains(parmVal.ValueStr, "["){
								parmVal.ValueStr = "[" + between(parmVal.ValueStr, "[", "]") +"]"
							}else if strings.Contains(parmVal.ValueStr, "{"){
								// if the value is a dict. {}
								parmVal.ValueStr = "{" + between(parmVal.ValueStr, "{", "}") + "}"
							}else if parmVal.ValueStr!= "" && parmVal.ValueStr[0] == '('{
								// if the value is a tuple ()
								m := strings.Split(parmVal.ValueStr, ")")[0]
								parmVal.ValueStr = m +")"
							} else{
								if strings.Contains(parmVal.ValueStr, "PosLL" ){
									// Special case: the default value is PosLL(..., ...)
									m := strings.Split(parmVal.ValueStr, ")")[0]
									parmVal.ValueStr = m+")"
								}else {
									m := strings.Split(parmVal.ValueStr, ")")[0]
									m = strings.Split(m, ",")[0]
									parmVal.ValueStr = m
								}
							}

							// Get the A9/boatVar's send message format and create the sample message.
							dataStr = after(content, "formatFBSend='")  // A9 message FB
							if dataStr == ""{
								dataStr = after(content, "formatValSend='") //A9 message send
								}
							if dataStr == ""{
								dataStr = after(content, "formatVal='")	// BoatVar message
								}
							// if the message format string is missing.
							if dataStr == ""{
								dataStr = "<"+parmVal.ValueStr+">"
								}else{
								s = strings.Split(dataStr, "'")
								dataStr = s[0]
							}
							parmVal.msgFmt = parmVal.mainTag + ";" + parmVal.KeyStr + ";" + dataStr

							// Get the A9/boatVar's comments and the string in help().
							if strings.Contains(content, ".help(_('") {
								helpStrList :=  strings.Split(content, ".help(_('")
								if len(helpStrList) >= 2{
									for  _, helpStr := range helpStrList[1:] {
										cmtStr := strings.Split(helpStr, ")")[0]
										comments += cmtStr
										}
									}
							}
							parmVal.desp = comments
							// check whether the var is read only.

							parmVal.permit = "editable"
							if strings.Contains(content, "VF_READ_ONLY"){
								parmVal.permit = "read only"
							}
							// Write the data to csv file.
							parmVal.KeyCHStr = "无"
							if value, ok := chineseMap[parmVal.KeyName]; ok {
								//do something here
								parmVal.KeyCHStr = value
							}
							csvline = [] string{parmVal.sysName, parmVal.mainTag, parmVal.KeyName, parmVal.KeyCHStr ,parmVal.KeyStr, parmVal.ValueStr, parmVal.permit, parmVal.msgFmt, parmVal.desp}
							err = writer.Write(csvline)
							checkError("Cannot write to file", err)
						}
						// Update the control tag after we finished written the csvLine.
						newGvVal = false
						comments = ""
					}
					// Read a new gv parameter.
					if len(newline) > 3 && newline[0:3] == "gv."{
						parmVal = new(ParamV)
						parmVal.desp = comments
						newGvVal = true
						content = strings.TrimSpace(newline)
					}else if newGvVal{
						content += strings.TrimSpace(newline)
					}
				}
		}
		if err := scanner.Err(); err != nil {
			log.Fatal(err)
		}
	}
	// Log in the time of the csv file creation.
	for _, value := range dataEnd {
		err := writer.Write(value)
		checkError("Cannot write to file", err)
	}
	// Finished all process
	fmt.Println("Finished process the variable files.")
}

// Handle the IO error.
func checkError(message string, err error) {
	if err != nil {
		log.Fatal(message, err)
	}
}